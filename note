# bash

# sudo chmod 666 /dev/ttyUSB0

#1. copy and paste ForceSensor.py to the folder.
#2. Plug the force sensor cable to the computer
#3. Give the permission to the ttyUSB0
#sudo chmod 666 /dev/ttyUSB0
#sudo chmod a+rw /dev/ttyUSB0

#4. Run the code


# To change the speed of the position control

# check /deoxys_control/deoxys/config/osc-pose-controller.yml

controller_type: OSC_POSE

is_delta: true

traj_interpolator_cfg:
  traj_interpolator_type: LINEAR_POSE
  time_fraction: 0.7    
  # Time_fraction is alpha. In low-level controller, the robot reaches to the target position in u_t when t pass around 70% of total steps.
  # In our case, low level controller is 500Hz, osc controller is 25Hz, it generates 25 steps everty action input in low level controllre.
  # Then, the robot reaches to the desired positon when t is 25*0.7 = 17.5 steps = 17. u_17 = desired position.

Kp:
  translation: 150.0
  #  translation: 800.0
  rotation: 250.0
# Kp is the stiffness of the translation or rotation movemetn in osc.

action_scale:
  translation: 0.05
  # this is the scaling number and limit the maximum movement in low level controller desired position. (Prevent quick movement in low level controller)
  # If you want to change the speed of the Panda, you should decrease this value. But it couldn't generate enough torque. Thus, we need to increase the Kp value.
  rotation: 1.0

residual_mass_vec: [0.0, 0.0, 0.0, 0.0, 0.1, 0.5, 0.5]
#residual_mass_vec: [0.0, 0.0, 0.0, 0.0, 0.1, 0.5, 0.5]

state_estimator_cfg:
  is_estimation: false
  state_estimator_type: EXPONENTIAL_SMOOTHING
  alpha_q: 0.9
  alpha_dq: 0.9
  alpha_eef: 1.0
  alpha_eef_vel: 1.0


Change translation or rotation gains.

----------------- Structure of osc controller --------------------------

Start with Target Delta Pose:
target_delta_pose = [0.0, 0.0, -0.15, 0.0, 0.0, 0.0]

1. High-Level Policy (20 Hz)
   |
   |-- Compute Action:
   |    action_pos = (target_pos - current_pos) * 10
   |    action_pos = [0.0, 0.0, -1.5] (Clipped to [-1.0, 1.0])
   |    Final Action = [0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0]
   |
   |-- Apply Action Scaling:
   |    Scaled Action = action * action_scale.translation
   |    Scaled Action = [0.0, 0.0, -0.05, 0.0, 0.0, 0.0]
   |
   |-- Construct OSC Message:
   |    osc_msg includes:
   |        - translational_stiffness
   |        - rotational_stiffness
   |        - goal (generated from Scaled Action)
   |
   |-- Construct Control Message:
   |    control_msg includes:
   |        - controller_type
   |        - traj_interpolator_type
   |        - traj_interpolator_time_fraction
   |        - osc_msg (which contains stiffness, goal, and residual mass vector)
   |
   |-- Send Control Message to Low-Level Control

2. Low-Level Control (500 Hz)
   |
   |-- Unpack Control Message:
   |    Extract osc_msg and its components (stiffness, goal, etc.)
   |
   |-- Interpolate Trajectory:
   |    Generate detailed trajectories at 500 Hz for each control step
   |
   |-- Execute Robot Movement:
   |    |
   |    |-- Calculate Torques Using OSC Formula:
   |         τ = J^T * Λ * (Kp * e - Kv * v) + τ_null
   |         |-- J: Jacobian
   |         |-- Λ: Mass Matrix
   |         |-- Kp: Stiffness Gains (translational and rotational)
   |         |-- e: Position and Orientation Error (from goal)
   |         |-- Kv: Damping Gains
   |         |-- v: Velocity
   |         |-- τ_null: Null Space Torque
   |    |
   |    |-- Control the robot according to the calculated torques
   |
   |-- Feedback Loop:
   |    |
   |    |-- Collect Sensor Data:
   |         - Position, velocity, and torque readings from the robot joints
   |
   |    |-- Send Sensor Data back to High-Level Policy
   |
   |-- High-Level Policy Adjusts Action:
   |    Based on the feedback received, adjust the next action for continuous control
